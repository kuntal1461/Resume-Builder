name: PR Flow Automation (Projects v2)

on:
  pull_request:
    types: [opened, ready_for_review]
  workflow_run:
    workflows: ["CI"]     # must match your CI workflow name
    types: [completed]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write
  repository-projects: write   # not used for user-owned projects, but harmless

env:
  # User-owned Project v2 (requires PAT with repo, project scopes)
  PROJECT_ID: PVT_kwHOA6RqoM4BHBmW
  STATUS_FIELD_ID: PVTSSF_lAHOA6RqoM4BHBmWzg35lDE

  OPTION_TODO: f75ad846
  OPTION_IN_PROGRESS: 47fc9ee4
  OPTION_CODE_REVIEW_REQUEST: 544d6251
  OPTION_IN_REVIEW: 464f60b6
  OPTION_DONE: 98236657

  USER_OWNER: kuntal1461
  USER_CONTRIB: afridpashahp

  CI_WORKFLOW_NAME: CI

jobs:
  # ─────────────────────────────────────────────────────────────
  # Auto-assign the *other* reviewer when PR opens / ready
  # (REST only → GITHUB_TOKEN is fine)
  # ─────────────────────────────────────────────────────────────
  auto_assign_reviewer:
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    steps:
      - name: Auto-request the opposite reviewer
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const author = pr.user.login;
            const { owner, repo } = context.repo;

            let reviewers = [];
            if (author === process.env.USER_CONTRIB) reviewers = [process.env.USER_OWNER];
            else if (author === process.env.USER_OWNER) reviewers = [process.env.USER_CONTRIB];
            else {
              core.info(`Author ${author} is neither ${process.env.USER_OWNER} nor ${process.env.USER_CONTRIB}; skipping.`);
              return;
            }

            await github.rest.pulls.requestReviewers({
              owner, repo, pull_number: pr.number, reviewers
            });
            core.info(`Requested reviewers: ${reviewers.join(", ")}`);

  # ─────────────────────────────────────────────────────────────
  # When CI completes successfully, move to "Code Review Request"
  # Uses GH_PAT for Projects v2 GraphQL; robust PR resolution.
  # ─────────────────────────────────────────────────────────────
  to_code_review_request:
    if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.name == 'CI' && github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Find PR → add to Project → set Status=Code Review Request → request reviewers
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}   # PAT required for user-owned Project v2
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;

            // 1) Try to get PR from workflow_run payload
            let prNumber = null;
            if (Array.isArray(run.pull_requests) && run.pull_requests.length > 0) {
              prNumber = run.pull_requests[0].number;
            }

            // 2) Fallback: search open PRs by head branch
            if (!prNumber && run.head_branch) {
              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr is:open head:${run.head_branch}`
              });
              if (search.data.items.length) prNumber = search.data.items[0].number;
            }

            // 3) Final fallback: search by head sha
            if (!prNumber) {
              const prs = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr sha:${run.head_sha}`
              });
              if (prs.data.items.length) prNumber = prs.data.items[0].number;
            }

            // 4) Skip gracefully if no PR (direct push case)
            if (!prNumber) {
              core.info("No PR associated with this workflow_run (direct push or no open PR). Skipping project/status update.");
              return;
            }

            // 5) Load PR & author
            const prFull = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const prNodeId = prFull.data.node_id;
            const author = prFull.data.user.login;

            // 6) Add to Project v2 (idempotent)
            const addResp = await github.graphql(`
              mutation($project: ID!, $content: ID!) {
                addProjectV2ItemById(input: { projectId: $project, contentId: $content }) {
                  item { id }
                }
              }
            `, { project: process.env.PROJECT_ID, content: prNodeId });
            const itemId = addResp.addProjectV2ItemById.item.id;

            // 7) Set Status = "Code Review Request"
            await github.graphql(`
              mutation($project: ID!, $item: ID!, $field: ID!, $option: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $project,
                  itemId: $item,
                  fieldId: $field,
                  value: { singleSelectOptionId: $option }
                }) { clientMutationId }
              }
            `, {
              project: process.env.PROJECT_ID,
              item: itemId,
              field: process.env.STATUS_FIELD_ID,
              option: process.env.OPTION_CODE_REVIEW_REQUEST
            });

            // 8) (Re)request the correct reviewer
            let reviewers = [];
            if (author === process.env.USER_CONTRIB) reviewers = [process.env.USER_OWNER];
            else if (author === process.env.USER_OWNER) reviewers = [process.env.USER_CONTRIB];

            if (reviewers.length) {
              await github.rest.pulls.requestReviewers({
                owner, repo, pull_number: prNumber, reviewers
              });
              core.info(`Requested reviewers: ${reviewers.join(", ")}`);
            }

  # ─────────────────────────────────────────────────────────────
  # When any review is submitted → set "In Review" (or CRR) + notify author
  # (GraphQL → GH_PAT)
  # ─────────────────────────────────────────────────────────────
  to_in_review:
    if: ${{ github.event_name == 'pull_request_review' }}
    runs-on: ubuntu-latest
    steps:
      - name: Set Status=In Review (or back to Code Review Request) & notify author
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}   # PAT required
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const prNodeId = pr.node_id;
            const author = pr.user.login;

            const reviewState = (context.payload.review.state || '').toLowerCase(); // approved | changes_requested | commented

            const addResp = await github.graphql(`
              mutation($project: ID!, $content: ID!) {
                addProjectV2ItemById(input: { projectId: $project, contentId: $content }) {
                  item { id }
                }
              }
            `, { project: process.env.PROJECT_ID, content: prNodeId });
            const itemId = addResp.addProjectV2ItemById.item.id;

            const nextOption = (reviewState === "changes_requested")
              ? process.env.OPTION_CODE_REVIEW_REQUEST
              : process.env.OPTION_IN_REVIEW;

            await github.graphql(`
              mutation($project: ID!, $item: ID!, $field: ID!, $option: String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId: $project,
                  itemId: $item,
                  fieldId: $field,
                  value: { singleSelectOptionId: $option }
                }) { clientMutationId }
              }
            `, {
              project: process.env.PROJECT_ID,
              item: itemId,
              field: process.env.STATUS_FIELD_ID,
              option: nextOption
            });

            const msg = (reviewState === "changes_requested")
              ? `@${author} Changes were requested. Please push updates and re-request review.`
              : `@${author} A reviewer has started/updated the review. Please wait for updates.`;
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: msg });

  # ─────────────────────────────────────────────────────────────
  # If approved & checks green → auto-merge main + set "Done"
  # (merge via REST; Project update via GH_PAT)
  # ─────────────────────────────────────────────────────────────
  automerge_and_done:
    if: ${{ github.event_name == 'pull_request_review' || github.event_name == 'check_suite' }}
    runs-on: ubuntu-latest
    steps:
      - name: Merge if approved & green; then set Status=Done
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}   # PAT required for Project v2 step; REST calls also work with PAT
          script: |
            const { owner, repo } = context.repo;

            async function findPrFromCheckSuite() {
              const run = context.payload.check_suite;
              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr sha:${run.head_sha}`
              });
              if (!search.data.items.length) return null;
              const prNum = search.data.items[0].number;
              const full = await github.rest.pulls.get({ owner, repo, pull_number: prNum });
              return full.data;
            }

            let pr;
            if (context.eventName === "pull_request_review") {
              pr = context.payload.pull_request;
            } else {
              pr = await findPrFromCheckSuite();
              if (!pr) { core.info("No PR tied to this check_suite; skipping."); return; }
            }

            if (pr.base.ref !== "main") {
              core.info(`Base branch is ${pr.base.ref}; only auto-merging to 'main'.`);
              return;
            }

            // 1) Check approvals
            const reviews = await github.rest.pulls.listReviews({ owner, repo, pull_number: pr.number });
            const hasApproval = reviews.data.some(r => (r.state || '').toUpperCase() === "APPROVED");

            // 2) Check combined status for head SHA (success)
            const combined = await github.rest.repos.getCombinedStatusForRef({
              owner, repo, ref: pr.head.sha
            });
            const checksGreen = combined.data.state === "success";

            if (!hasApproval || !checksGreen) {
              core.info(`Not merging: approved=${hasApproval}, checksGreen=${checksGreen}`);
              return;
            }

            // 3) Merge (squash)
            await github.rest.pulls.merge({
              owner, repo, pull_number: pr.number,
              commit_title: `Auto-merge PR #${pr.number}`,
              merge_method: "squash"
            });
            core.info(`Merged PR #${pr.number} into main.`);

            // 4) Add to Project & set Status = "Done"
            const addResp = await github.graphql(`
              mutation($project: ID!, $content: ID!) {
                addProjectV2ItemById(input: { projectId: $project, contentId: $content }) {
                  item { id }
                }
              }
            `, { project: process.env.PROJECT_ID, content: pr.node_id });
            const itemId = addResp.addProjectV2ItemById.item.id;

            await github.graphql(`
              mutation($project: ID!, $item: ID!, $field: ID!, $option: String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId: $project,
                  itemId: $item,
                  fieldId: $field,
                  value: { singleSelectOptionId: $option }
                }) { clientMutationId }
              }
            `, {
              project: process.env.PROJECT_ID,
              item: itemId,
              field: process.env.STATUS_FIELD_ID,
              option: process.env.OPTION_DONE
            });
            core.info(`Set Project status to Done.`);
